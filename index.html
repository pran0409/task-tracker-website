<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Tracker</title>
    <!-- Favicon for the browser tab -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMyIgeT0iNSI gud2lkdGg9IjE4IiBoZWlnaHQ9IjE0IiByeD0iMiIgcnk9IjIiIGZpbGw9IiM2MzY2RDAiLz4KPHBhdGggZD0iTTEwIDlMMjEgMy41TTIzIDkuNUwyMSA2IiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik03IDEzTDEyIDE4TDE3IDEzIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjwvYXN2Zz4=">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .task {
            touch-action: none; /* Recommended for draggable elements */
            cursor: grab;
            user-select: none;
        }
        .task.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .column {
            min-height: 200px;
        }
        .confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
        /* Custom modal for alerts and confirmations */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s;
        }
        .modal-overlay.active {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            /* Force modal background to black and text to light gray regardless of body's dark mode */
            background-color: rgb(31,41,55); /* Always black for the modal background */
            color: #d1d5db; /* Light gray text for contrast */
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            max-width: 600px; /* Increased max-width for LLM response */
            width: 90%;
            text-align: left; /* Align text left for better readability of LLM response */
            transform: scale(0.95);
            transition: transform 0.3s ease-out;
            max-height: 80vh; /* Limit height for scrollability */
            overflow-y: auto; /* Enable scrolling for long content */
            position: relative; /* Needed for absolute positioning of close button */
        }
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }
        /* Specific overrides for text within modal content, making sure it's always light */
        .modal-content p,
        .modal-content h1,
        .modal-content h2,
        .modal-content h3,
        .modal-content h4,
        .modal-content strong,
        .modal-content ul,
        .modal-content ol,
        .modal-content li {
            color: #e2e8f0; /* Even lighter gray for primary text within the black modal */
        }
        .modal-content .prose {
             color: #e2e8f0; /* Apply to prose content as well */
        }


        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px auto;
        }
        .modal-close-btn {
            position: absolute;
            top: 0.75rem; /* 12px from top */
            right: 0.75rem; /* 12px from right */
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem; /* Add padding for easier click/tap */
            color: #9ca3af; /* Gray-400 */
            transition: color 0.2s ease-in-out;
            border-radius: 9999px; /* Make it circular */
        }
        .modal-close-btn:hover {
            color: #ef4444; /* Red-500 on hover */
            background-color: rgba(255, 255, 255, 0.1); /* Slight background on hover */
        }
        /* No need for .dark .modal-close-btn specific overrides as modal background is now always dark */
        .dark .modal-close-btn {
             color: #9ca3af;
        }
        .dark .modal-close-btn:hover {
            color: #ef4444;
            background-color: rgba(255, 255, 255, 0.1);
        }


        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900 dark:text-white">Task Board</h1>
            <p class="text-gray-600 dark:text-gray-400 mt-2">Drag and drop tasks to change their status.</p>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6" id="kanban-board">
            <div id="todo" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold p-4 border-b-2 border-red-500 text-gray-700 dark:text-gray-200">To Do</h2>
                <div class="p-4 space-y-4 column" data-status="todo">
                </div>
            </div>

            <div id="inprogress" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold p-4 border-b-2 border-yellow-500 text-gray-700 dark:text-gray-200">In Progress</h2>
                <div class="p-4 space-y-4 column" data-status="inprogress">
                </div>
            </div>

            <div id="done" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold p-4 border-b-2 border-green-500 text-gray-700 dark:text-gray-200">Done</h2>
                <div class="p-4 space-y-4 column" data-status="done">
                </div>
            </div>
        </div>

        <div class="mt-8 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg">
            <h3 class="text-xl font-semibold mb-4 text-gray-700 dark:text-gray-200">Add a New Task</h3>
            <div class="flex flex-col sm:flex-row items-center gap-4">
                <input type="text" id="new-task-input" placeholder="Enter your new task..." class="flex-grow p-3 border-2 border-gray-300 dark:border-gray-600 dark:bg-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-800 dark:text-gray-200">
                
                <div class="flex items-center space-x-4 mt-2 sm:mt-0">
                    <label class="inline-flex items-center">
                        <input type="radio" class="form-radio text-red-500" name="newTaskStatus" value="todo" checked>
                        <span class="ml-2 text-gray-700 dark:text-gray-200">To Do</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" class="form-radio text-yellow-500" name="newTaskStatus" value="inprogress">
                        <span class="ml-2 text-gray-700 dark:text-gray-200">In Progress</span>
                    </label>
                </div>

                <button id="add-task-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 shadow-md hover:shadow-lg w-full sm:w-auto">
                    Add Task
                </button>
            </div>
        </div>
    </div>

    <canvas id="confetti-canvas" class="confetti-canvas"></canvas>

    <!-- Custom Modal for Alerts, Confirmations, and LLM Responses -->
    <div id="custom-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close-btn" title="Close">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <p id="modal-message" class="text-lg font-medium mb-4"></p>
            <div id="modal-loading-spinner" class="loading-spinner hidden"></div>
            <div id="modal-response-content" class="mt-4 prose dark:prose-invert" style="max-width: none;">
                <!-- LLM response content will be inserted here -->
            </div>
            <div class="modal-buttons">
                <button id="modal-confirm-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 shadow-md" style="display: none;">Confirm</button>
                <button id="modal-cancel-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg transition duration-300 shadow-md" style="display: none;">Cancel</button>
                <button id="modal-ok-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 shadow-md" style="display: none;">OK</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get references to DOM elements
            const addTaskBtn = document.getElementById('add-task-btn');
            const newTaskInput = document.getElementById('new-task-input');
            const todoColumn = document.querySelector('#todo .column');
            const inprogressColumn = document.querySelector('#inprogress .column');
            const doneColumn = document.querySelector('#done .column');
            const columns = document.querySelectorAll('.column');
            let draggedTask = null;

            // Modal elements
            const customModalOverlay = document.getElementById('custom-modal-overlay');
            const modalMessage = document.getElementById('modal-message');
            const modalLoadingSpinner = document.getElementById('modal-loading-spinner');
            const modalResponseContent = document.getElementById('modal-response-content');
            const modalConfirmBtn = document.getElementById('modal-confirm-btn');
            const modalCancelBtn = document.getElementById('modal-cancel-btn');
            const modalOkBtn = document.getElementById('modal-ok-btn');
            const modalCloseBtn = document.getElementById('modal-close-btn');

            // --- Local Storage Keys ---
            const LOCAL_STORAGE_KEY = 'kanbanTasks';

            /**
             * Displays a custom modal message.
             * @param {string} message - The message to display.
             * @param {boolean} isConfirmation - True if it's a confirmation, false for a simple alert.
             * @param {string} contentHtml - Optional HTML content to display below the message.
             * @param {boolean} showLoading - True to show a loading spinner.
             * @returns {Promise<boolean>} - Resolves with true for confirm, false for cancel/OK.
             */
            function showCustomModal(message, isConfirmation = false, contentHtml = '', showLoading = false) {
                return new Promise((resolve) => {
                    modalMessage.textContent = message;
                    modalResponseContent.innerHTML = contentHtml;

                    // Reset button states
                    modalConfirmBtn.style.display = 'none';
                    modalCancelBtn.style.display = 'none';
                    modalOkBtn.style.display = 'none';
                    modalLoadingSpinner.classList.add('hidden'); // Hide spinner by default
                    modalCloseBtn.style.display = 'inline-block'; // Show close button by default

                    if (showLoading) {
                        modalLoadingSpinner.classList.remove('hidden');
                        modalResponseContent.classList.add('hidden'); // Hide content while loading
                        modalCloseBtn.style.display = 'none'; // Hide close button while loading
                        // No confirm/cancel/ok buttons when loading
                    } else {
                        modalLoadingSpinner.classList.add('hidden');
                        modalResponseContent.classList.remove('hidden'); // Show content if not loading
                        modalCloseBtn.style.display = 'inline-block'; // Ensure close button is visible

                        // Set up buttons based on type
                        if (isConfirmation) {
                            modalConfirmBtn.style.display = 'inline-block';
                            modalCancelBtn.style.display = 'inline-block';
                            modalConfirmBtn.onclick = () => {
                                customModalOverlay.classList.remove('active');
                                resolve(true);
                            };
                            modalCancelBtn.onclick = () => {
                                customModalOverlay.classList.remove('active');
                                resolve(false);
                            };
                        } else {
                            modalOkBtn.style.display = 'inline-block';
                            modalOkBtn.onclick = () => {
                                customModalOverlay.classList.remove('active');
                                resolve(true);
                            };
                        }
                    }

                    // Add event listener for the new close button
                    modalCloseBtn.onclick = () => {
                        customModalOverlay.classList.remove('active');
                        resolve(false); // Treat closing with 'X' as a cancellation for consistency
                    };

                    customModalOverlay.classList.add('active');
                });
            }

            // --- Helper to get border color class based on status ---
            function getBorderColorClass(status) {
                const borderColorMap = {
                    todo: 'border-red-500',
                    inprogress: 'border-yellow-500',
                    done: 'border-green-500'
                };
                return borderColorMap[status] || 'border-gray-300'; // Default if status is unexpected
            }

            // --- Task Creation ---
            /**
             * Creates a new HTML element for a task.
             * @param {string} taskText - The text content of the task.
             * @param {string} status - The status of the task ('todo', 'inprogress', 'done').
             * @param {string} taskId - Unique ID for the task.
             * @returns {HTMLElement} The created task element.
             */
            function createTaskElement(taskText, status = 'todo', taskId = 'task-' + Date.now()) {
                const task = document.createElement('div');
                task.className = `task bg-white dark:bg-gray-700 p-4 rounded-lg shadow-md border-l-4 ${getBorderColorClass(status)} relative group`;
                task.setAttribute('draggable', 'true');
                task.setAttribute('data-id', taskId);
                task.setAttribute('data-status', status); // Store status on the element

                let elaborateButtonHtml = '';
                // Only add the elaborate button if the task is NOT in the 'done' status
                if (status !== 'done') {
                    elaborateButtonHtml = `
                        <button class="elaborate-task-btn bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold py-1 px-3 rounded-lg transition duration-200 shadow-md">
                            âœ¨ Elaborate Task
                        </button>
                    `;
                }

                task.innerHTML = `
                    <p class="text-gray-800 dark:text-gray-200 mb-2">${taskText}</p>
                    <div class="flex flex-col sm:flex-row gap-2">
                        ${elaborateButtonHtml}
                        <button class="delete-task-btn bg-red-500 hover:bg-red-600 text-white text-sm p-1 rounded-full opacity-0 group-hover:opacity-100 transition-opacity duration-200 absolute top-2 right-2" title="Delete Task">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm1 4a1 100 2h4a1 1 0 100-2H8z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                `;
                return task;
            }

            /**
             * Adds a new task to the board or loads an existing task.
             * @param {string|null} taskTextFromInput - Text for the task (null for new input).
             * @param {string|null} statusFromInput - Status for the task (null for new input).
             * @param {string|null} taskIdFromLoad - ID for the task (null for new task).
             */
            async function addTask(taskTextFromInput = null, statusFromInput = null, taskIdFromLoad = null) {
                const taskText = taskTextFromInput || newTaskInput.value.trim();
                if (taskText === '') {
                    await showCustomModal("Task description can't be empty!");
                    return;
                }

                // Determine status: from function argument (for loading) or from radio buttons (for new task)
                let selectedStatus = statusFromInput;
                if (!selectedStatus) {
                    const selectedRadioButton = document.querySelector('input[name="newTaskStatus"]:checked');
                    // If no radio is checked, default to 'todo'
                    selectedStatus = selectedRadioButton ? selectedRadioButton.value : 'todo'; 
                }

                const taskId = taskIdFromLoad || 'task-' + Date.now();
                const taskElement = createTaskElement(taskText, selectedStatus, taskId);
                
                // Append to the correct column based on status
                if (selectedStatus === 'todo') {
                    todoColumn.appendChild(taskElement);
                } else if (selectedStatus === 'inprogress') {
                    inprogressColumn.appendChild(taskElement);
                } else if (selectedStatus === 'done') {
                    doneColumn.appendChild(taskElement);
                }
                
                newTaskInput.value = ''; // Clear the input field after adding
                document.querySelector('input[name="newTaskStatus"][value="todo"]').checked = true; // Reset radio to 'To Do'
                newTaskInput.focus(); // Auto-focus the input field
                addDragEventsToTask(taskElement);
                addDeleteEventToTask(taskElement);
                // Only add elaborate event if the status is not 'done'
                if (selectedStatus !== 'done') {
                    addElaborateEventToTask(taskElement);
                }
                saveTasks(); // Save tasks after adding
            }

            // Event listeners for adding tasks
            addTaskBtn.addEventListener('click', () => addTask(null, null));
            newTaskInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addTask(null, null);
                }
            });

            // --- Drag and Drop Functionality ---
            /**
             * Adds drag event listeners to a task element.
             * @param {HTMLElement} task - The task element to add events to.
             */
            function addDragEventsToTask(task) {
                task.addEventListener('dragstart', () => {
                    draggedTask = task;
                    // Use setTimeout to ensure the class is added after the drag operation begins,
                    // preventing the original element from briefly showing before the ghost image takes over.
                    setTimeout(() => {
                        task.classList.add('dragging');
                    }, 0);
                });

                task.addEventListener('dragend', () => {
                    task.classList.remove('dragging');
                    draggedTask = null;
                    saveTasks(); // Save tasks after drag ends
                });
            }

            // --- Delete Task Functionality ---
            /**
             * Adds a click event listener to the delete button of a task.
             * @param {HTMLElement} task - The task element containing the delete button.
             */
            function addDeleteEventToTask(task) {
                const deleteButton = task.querySelector('.delete-task-btn');
                if (deleteButton) {
                    deleteButton.addEventListener('click', async (e) => {
                        e.stopPropagation(); // Prevent dragstart if clicking delete button
                        // Show a custom confirmation modal
                        const confirmed = await showCustomModal('Are you sure you want to delete this task?', true);
                        if (confirmed) {
                            task.remove();
                            saveTasks(); // Save tasks after deleting
                        }
                    });
                }
            }

            // --- Gemini API Integration: Elaborate Task ---
            /**
             * Adds a click event listener to the "Elaborate Task" button.
             * @param {HTMLElement} task - The task element containing the button.
             */
            function addElaborateEventToTask(task) {
                const elaborateButton = task.querySelector('.elaborate-task-btn');
                if (elaborateButton) {
                    elaborateButton.addEventListener('click', async (e) => {
                        e.stopPropagation(); // Prevent dragstart if clicking elaborate button
                        const taskText = task.querySelector('p').textContent;
                        await elaborateTaskWithGemini(taskText);
                    });
                }
            }

            /**
             * Calls the Gemini API to elaborate on a given task.
             * @param {string} taskText - The text of the task to elaborate.
             */
            async function elaborateTaskWithGemini(taskText) {
                showCustomModal('Generating task breakdown...', false, '', true); // Show loading spinner

                try {
                    const prompt = `Given the task: "${taskText}", please provide a detailed breakdown into actionable sub-tasks, including suggested steps, key considerations, and potential tools or resources. Format your response clearly using Markdown (e.g., bullet points for sub-tasks, bold for important terms).`;
                    
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = { contents: chatHistory };
                    const apiKey = ""; // Keep this empty; Canvas will inject
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        // If the HTTP response status is not 2xx
                        const errorData = await response.json().catch(() => ({ message: 'No JSON response' }));
                        showCustomModal(`API Error: ${response.status} ${response.statusText}. Please try again.`, false);
                        console.error('Gemini API HTTP Error:', response.status, response.statusText, errorData);
                        return; // Exit the function
                    }

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const generatedText = result.candidates[0].content.parts[0].text;
                        // Display the generated text in the modal
                        showCustomModal(`Elaboration for: "${taskText}"`, false, convertMarkdownToHtml(generatedText));
                    } else {
                        // If API call was successful but response structure is unexpected
                        showCustomModal('Failed to elaborate on the task. Unexpected response from AI. Please try again.', false);
                        console.error('Gemini API response structure unexpected:', result);
                    }
                } catch (error) {
                    // Catch network errors or issues with response.json() parsing
                    showCustomModal('An error occurred while connecting to or processing response from AI. Please check your internet connection and try again.', false);
                    console.error('Error during Gemini API call:', error);
                }
            }

            /**
             * Basic Markdown to HTML converter. This is a simplified version and may not support all Markdown.
             * It primarily handles lists, bold text, and newlines.
             * @param {string} markdownText - The Markdown string to convert.
             * @returns {string} The HTML string.
             */
            function convertMarkdownToHtml(markdownText) {
                let html = markdownText;

                // Convert bold text (**text** or __text__)
                html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');

                // Convert headings (simple # for h3, ## for h4, etc.)
                html = html.replace(/^### (.*$)/gim, '<h4>$1</h4>');
                html = html.replace(/^## (.*$)/gim, '<h3>$1</h3>');
                html = html.replace(/^# (.*$)/gim, '<h2>$1</h2>');

                // Convert unordered lists (* item or - item)
                html = html.replace(/^\s*[\*\-]\s+(.*)$/gim, '<li>$1</li>');
                if (html.includes('<li>')) {
                    html = `<ul>${html}</ul>`;
                }
                 // Convert ordered lists (1. item)
                html = html.replace(/^\s*\d+\.\s+(.*)$/gim, '<li>$1</li>');
                if (html.includes('<li>') && !html.includes('<ul>')) { // Only if it's an ordered list and not already an unordered list
                    html = `<ol>${html}</ol>`;
                }

                // Handle newlines as paragraphs for remaining text not in lists/headings
                // This replaces multiple newlines with a single <p> tag, preserving <br> for single newlines within text
                html = html.split('\n\n').map(paragraph => `<p>${paragraph.replace(/\n/g, '<br>')}</p>`).join('');

                return html;
            }


            // Event listeners for drag and drop on columns
            columns.forEach(column => {
                column.addEventListener('dragover', e => {
                    e.preventDefault(); // Necessary to allow dropping
                    const afterElement = getDragAfterElement(column, e.clientY);
                    const draggable = document.querySelector('.dragging');
                    if (draggable) { // Ensure there is a dragged element
                        if (afterElement == null) {
                            column.appendChild(draggable);
                        } else {
                            column.insertBefore(draggable, afterElement);
                        }
                    }
                });

                column.addEventListener('drop', e => {
                    e.preventDefault();
                    if (!draggedTask) return; // If no task is being dragged, do nothing
                    
                    const targetColumn = e.currentTarget;
                    const status = targetColumn.dataset.status;

                    // Get the task's old status before updating to the new status
                    const oldStatus = draggedTask.getAttribute('data-status');

                    // Update task card's border color based on the column
                    draggedTask.classList.remove('border-red-500', 'border-yellow-500', 'border-green-500');
                    draggedTask.classList.add(getBorderColorClass(status));
                    draggedTask.setAttribute('data-status', status); // Update the task's data-status

                    // Remove/Add Elaborate Task button based on status change
                    const elaborateButton = draggedTask.querySelector('.elaborate-task-btn');
                    if (status === 'done' && elaborateButton) {
                        elaborateButton.remove(); // Remove if moved to 'done'
                    } else if (status !== 'done' && !elaborateButton) {
                        // Re-create and add the button if moved OUT of 'done'
                        // Need to re-create the whole button structure and then attach the event
                        const taskText = draggedTask.querySelector('p').textContent;
                        const tempTask = createTaskElement(taskText, status, draggedTask.dataset.id);
                        const newElaborateButton = tempTask.querySelector('.elaborate-task-btn');
                        if (newElaborateButton) {
                            draggedTask.querySelector('.flex').prepend(newElaborateButton);
                            addElaborateEventToTask(newElaborateButton.closest('.task')); // Add event to parent task
                        }
                    }

                    // Trigger confetti if task is moved to "Done"
                    if (status === 'done' && oldStatus !== 'done') { // Only trigger if it just became done
                        triggerConfetti();
                    }
                    saveTasks(); // Save tasks after dropping
                });
            });

            /**
             * Determines where to insert a dragged element in a column.
             * @param {HTMLElement} container - The column element.
             * @param {number} y - The Y-coordinate of the mouse pointer.
             * @returns {HTMLElement|null} The element before which the dragged element should be inserted, or null if it should be appended.
             */
            function getDragAfterElement(container, y) {
                // Get all draggable elements within the container that are NOT currently being dragged
                const draggableElements = [...container.querySelectorAll('.task:not(.dragging)')];

                // Reduce the list to find the closest element to the mouse's Y position
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect(); // Get the size and position of the child element
                    // Calculate the offset from the middle of the child element to the mouse's Y
                    const offset = y - box.top - box.height / 2;
                    // If the offset is negative (mouse is above the middle of the child)
                    // and it's closer to zero than the current closest offset, then this is the new closest element
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element; // Initialize with a very small offset and no element
            }

            // --- Local Storage Functions ---
            /**
             * Saves the current state of tasks to local storage.
             */
            function saveTasks() {
                const tasks = [];
                document.querySelectorAll('.column').forEach(column => {
                    const status = column.dataset.status;
                    column.querySelectorAll('.task').forEach(taskElement => {
                        tasks.push({
                            id: taskElement.dataset.id,
                            text: taskElement.querySelector('p').textContent,
                            status: status
                        });
                    });
                });
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(tasks));
            }

            /**
             * Loads tasks from local storage and renders them on the board.
             */
            function loadTasks() {
                const savedTasks = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedTasks) {
                    const tasks = JSON.parse(savedTasks);
                    tasks.forEach(task => {
                        addTask(task.text, task.status, task.id); // Pass task.text and task.status for loading
                    });
                }
            }

            // --- Initial Load of Tasks ---
            loadTasks();


            // --- Confetti Logic ---
            const confettiCanvas = document.getElementById('confetti-canvas');
            const confettiCtx = confettiCanvas.getContext('2d');
            let confettiParticles = [];
            let animationFrameId; // To store the animation frame ID for cancellation

            /**
             * Triggers a confetti animation on the screen.
             */
            function triggerConfetti() {
                // Set canvas dimensions to match the window
                confettiCanvas.width = window.innerWidth;
                confettiCanvas.height = window.innerHeight;
                confettiParticles = []; // Clear existing particles

                const particleCount = 200;
                const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800'];
                
                // Create confetti particles with random properties
                for (let i = 0; i < particleCount; i++) {
                    confettiParticles.push({
                        x: Math.random() * confettiCanvas.width, // Random X position across the width
                        y: -20, // Start from slightly above the top of the screen
                        radius: Math.random() * 5 + 2, // Random size
                        color: colors[Math.floor(Math.random() * colors.length)], // Random color
                        speed: Math.random() * 3 + 2, // Downward speed
                        angle: Math.random() * Math.PI * 2, // Initial angle for horizontal movement
                        fallSpeed: Math.random() * 2 + 1, // Additional fall speed for variation
                        opacity: 1, // Start fully opaque
                        rotation: Math.random() * 10, // Initial rotation
                        spin: (Math.random() - 0.5) * 0.2 // Rotation speed and direction
                    });
                }
                // Start the animation loop
                animateConfetti();
            }

            /**
             * Animates the confetti particles.
             */
            function animateConfetti() {
                // Clear the entire canvas for the next frame
                confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
                
                let activeParticles = false; // Flag to check if there are still active particles

                confettiParticles.forEach((p) => {
                    if (p.opacity > 0) { // Only animate particles that are still visible
                        activeParticles = true;
                        // Update particle position and properties
                        p.y += p.fallSpeed;
                        p.x += Math.sin(p.angle) * p.speed;
                        p.angle += 0.05; // Slightly change angle for wobbly movement
                        p.rotation += p.spin; // Rotate the particle

                        p.opacity -= 0.005; // Fade out over time

                        // Draw the particle
                        confettiCtx.save(); // Save the current canvas state
                        confettiCtx.globalAlpha = p.opacity; // Apply opacity
                        confettiCtx.translate(p.x, p.y); // Move origin to particle's center
                        confettiCtx.rotate(p.rotation); // Apply rotation
                        confettiCtx.fillStyle = p.color; // Set particle color
                        confettiCtx.fillRect(-p.radius, -p.radius, p.radius * 2, p.radius * 2); // Draw square particle
                        confettiCtx.restore(); // Restore the canvas state
                    }
                });

                // Continue animation if there are active particles, otherwise clear and cancel
                if (activeParticles) {
                    animationFrameId = requestAnimationFrame(animateConfetti);
                } else {
                    confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height); // Final clear
                    cancelAnimationFrame(animationFrameId); // Stop the animation loop
                }
            }

            // Handle window resize to adjust confetti canvas size
            window.addEventListener('resize', () => {
                confettiCanvas.width = window.innerWidth;
                confettiCanvas.height = window.innerHeight;
            });
        });
    </script>

</body>
</html>
